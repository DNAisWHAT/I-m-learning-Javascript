__11강 ~ 12강(137p ~ 164p)__

***
값 수정과 재할당은 다르다.  
값에 의한 전달은 결국 메모리 주소를 다르게 가진다.   
```javascript
var x = 10;
var y = x; // 값의 의한 전달, JS 에서는 똑같은 원시값을 가진 다른 메모리 공간에 값을 참조하도록 서로 다른 메모리 주소를 가진다.
``` 
식별자 -> 메모리 주소 -> 메모리 공간 -> 원시값 , 수정이 불가능하다. 불변성   
식별자 -> 메모리 주소 -> 메모리 공간 -> 참조값 -> 객체 주소 -> 객체이자 값 , 수정이 가능하다   
결국 식별자는 객체의 참조값이다.   
__객체 리터럴은 평가될 때마다 객체를 생성한다.__   
리터럴은 값을 생성하기 위한 표기법이다.   
__함수는 객체다.__   
JS 에서 말하는 정의란 변수에 값을 넣어 명확히 해주는 걸 말한다.   
함수는 선언문을 통해서 암묵적으로 함수 이름과 동일한 이름의 식별자가 만들어지고 함수 객체가 할당된다. 또 변수는 선언, 함수는 정의라고 한다.   
__함수선언문은 표현식이 아닌 문 이기 때문에 표현식의 값이 undefined이다.__   
```javascript
function add(x, y) {
    return x + y;
}
```
__값의 성질을 갖는 객체를 일급객체라고 한다. 함수가 대표적이다.__   
항수 리터럴로 함수 객체를 만들 수 있기 때문에 함수 리터럴을 이용해서 값으로 나타낼 수 있다. 함수 표현식이다.   
함수 선언문와 함수 리터럴은 문맥에 따라 다르게 해석한다. 대표 사례는 함수 표현식이다.
```javascript
// 여기서 함수는 선언식이라고 판단하지 않고 함수 리터럴이라고 판단한다. 
var foo = function bar(x,y) {
    return x + y;
}; 
```
__함수를 호출한다는 것은 함수의 식별자를 호출하는 일이다. 무조건 함수 이름을 부르는 것은 아니다.__   
```javascript
function foo() {
    return 0;
} 

foo(); // 암묵적인 식별자 이름과 함수 이름은 동일하다.

var bar = function che() {
    console.log('che');
};
che(); // X. 함수 che를 부르는 건 함수 내부에서 가능하다. 식별자 bar를 호출해야 한다.  
```


 

